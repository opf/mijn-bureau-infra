global:
  security:
    allowInsecureImages: true

  defaultStorageClass: {{ coalesce .Values.pvc.openproject.openproject.storageClass .Values.pvc.default.storageClass | quote }}
  storageClass: {{ coalesce .Values.pvc.openproject.openproject.storageClass .Values.pvc.default.storageClass | quote }}
  imagePullSecrets:
    - name: {{ (coalesce .Values.container.openproject.imagePullSecret .Values.container.default.imagePullSecret) | quote }}

image:
  registry: {{ (coalesce .Values.container.openproject.registry .Values.container.default.registry) | quote }}
  repository: {{ .Values.container.openproject.repository | quote }}
  tag: {{ .Values.container.openproject.tag | quote }}

autoscaling:
  hpa: {{ .Values.autoscaling.horizontal.openproject | toYaml | nindent 4 }}

ingress:
  enabled: true
  host: {{ .Values.global.hostname.openproject }}.{{ .Values.global.domain }}
  ingressClassName: {{ .Values.cluster.ingress.className | quote }}
  tls:
    enabled: true
    secretName: {{ printf "%s-tls" .Values.global.hostname.openproject }}
  annotations:
    {{- if .Values.cluster.ingress.annotations }}
    {{ .Values.cluster.ingress.annotations | toYaml | nindent 4 }}
    {{- end }}
    {{- if eq .Values.cluster.ingress.type "nginx" }}
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    {{- end }}
    {{- if eq .Values.cluster.ingress.type "haproxy-openshift" }}
    haproxy.router.openshift.io/ssl-redirect: "true"
    {{- end }}

# Database configuration
database:
  host: {{ .Values.database.openproject.host }}
  port: {{ .Values.database.openproject.port }}
  database: {{ .Values.database.openproject.name }}
  username: {{ .Values.database.openproject.user }}
  password: {{ .Values.database.openproject.password }}

# Cache configuration (using Redis instead of Memcached)
cache:
  host: {{ .Values.cache.openproject.host }}
  port: {{ .Values.cache.openproject.port }}
  password: {{ .Values.cache.openproject.password }}

# PostgreSQL configuration (use embedded chart with our password)
postgresql:
  bundled: true
  image:
    registry: {{ coalesce .Values.container.postgres.registry .Values.container.default.registry | default "docker.io" | quote }}
    repository: {{ .Values.container.postgres.repository | default "bitnami/postgresql" | quote }}
    tag: {{ .Values.container.postgres.tag | default "17.5.0-debian-12-r18" | quote }}
  auth:
    postgresPassword: {{ .Values.database.openproject.adminpassword | quote }}
    username: {{ .Values.database.openproject.user | quote }}
    password: {{ .Values.database.openproject.password | quote }}
    database: {{ .Values.database.openproject.name | quote }}

# Redis configuration (using Redis instead of Memcached)
redis:
  image:
    registry: {{ (coalesce .Values.container.redis.registry .Values.container.default.registry) | quote }}
    repository: {{ .Values.container.redis.repository | quote }}
    tag: {{ .Values.container.redis.tag | quote }}

# OIDC configuration
oidc:
  enabled: true
  provider:
    name: "Keycloak"
    host: {{ .Values.global.hostname.keycloak }}.{{ .Values.global.domain }}
    identifier: {{ .Values.authentication.client.openproject.client_id }}
    secret: {{ .Values.authentication.client.openproject.client_secret }}
    authorization_endpoint: "{{ .Values.authentication.oidc.authorization_endpoint }}"
    token_endpoint: "{{ .Values.authentication.oidc.token_endpoint }}"
    userinfo_endpoint: "{{ .Values.authentication.oidc.userinfo_endpoint }}"
    jwks_uri: "{{ .Values.authentication.oidc.issuer }}/protocol/openid-connect/certs"
    scope: ["openid", "profile", "email"]

# SMTP configuration
smtp:
  enabled: {{ .Values.smtp.enabled }}
  host: {{ .Values.smtp.host | quote }}
  port: {{ .Values.smtp.port }}
  protocol: {{ .Values.smtp.protocol | quote }}
  from_address: {{ .Values.smtp.fromAddress | quote }}
  tls:
    enabled: {{ .Values.smtp.tls.enabled }}
    force: {{ .Values.smtp.tls.force }}
    require_transport_security: {{ .Values.smtp.tls.requireTransportSecurity }}
  username: {{ .Values.smtp.username | quote }}
  password: {{ .Values.smtp.password | quote }}

# Resources
resources:
  limits:
    cpu: "4"
    memory: 4Gi
  requests:
    cpu: 250m
    memory: 512Mi

# Environment variables
env:
  TMPDIR: /app/tmp
  TMP: /app/tmp
  TEMP: /app/tmp

# Security context
podSecurityContext: {{ .Values.security.default.podSecurityContext | toYaml | nindent 2 }}

containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  privileged: false
  readOnlyRootFilesystem: true
  runAsGroup: 1001
  runAsNonRoot: true
  runAsUser: 1001
  seLinuxOptions: {}
  seccompProfile:
    type: RuntimeDefault

# Enable temporary volumes to fix seeder issues (learned from opnc-helm-chart)
openproject:
  useTmpVolumes: true
  tmpVolumesStorageClassName: "standard"
  tmpVolumesAnnotations:
    volume.beta.kubernetes.io/storage-class: "standard"
  tmpVolumesLabels:
    app.kubernetes.io/component: "temp-storage"
  # Additional volume for custom temp directory
  # Note: Using existing /app/tmp mount from OpenProject chart
  # The OpenProject chart already handles tmp directory permissions
  # Add init container to create tmp directory in persistent volume
  extraInitContainers:
    - name: "init-tmp-dir"
      image: "busybox:1.36"
      command: ["sh", "-c"]
      args:
        - |
          mkdir -p /var/openproject/assets/tmp
          chown -R 1001:1001 /var/openproject/assets/tmp
          chmod -R 755 /var/openproject/assets/tmp
      volumeMounts:
        - name: "data"
          mountPath: "/var/openproject/assets"
      securityContext:
        runAsUser: 0
        runAsGroup: 0

# Seeder job configuration with proper resources (from OpenProject 7.1.0+)
seederJob:
  resources:
    requests:
      memory: "512Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "500m"
  # Ensure seeder job has proper environment variables
  env:
    TMPDIR: /var/openproject/assets/tmp
    TMP: /var/openproject/assets/tmp
    TEMP: /var/openproject/assets/tmp
    RUBY_OPT: "-W0"
  # Mount the same tmp volume as the main application
  # Note: /app/tmp is already mounted by the OpenProject chart
  # Add init container to create tmp directory with proper permissions
  extraInitContainers:
    - name: "init-tmp-dir"
      image: "busybox:1.36"
      command: ["sh", "-c"]
      args:
        - |
          mkdir -p /var/openproject/assets/tmp
          chown -R 1001:1001 /var/openproject/assets/tmp
          chmod -R 755 /var/openproject/assets/tmp
      volumeMounts:
        - name: "data"
          mountPath: "/var/openproject/assets"
      securityContext:
        runAsUser: 0
        runAsGroup: 0

# Environment variables for all containers (including seeder)
# Fix for Ruby tmpdir issues: Use dedicated writable temp directory
# instead of world-writable /tmp to avoid security warnings
environment:
  TMPDIR: /var/openproject/assets/tmp
  TMP: /var/openproject/assets/tmp
  TEMP: /var/openproject/assets/tmp
  # Suppress Ruby warnings about world-writable temp directories
  RUBY_OPT: "-W0"

# Network policy
networkPolicy:
  enabled: true
  allowExternal: false
  allowExternalEgress: false

  extraEgress:
    # Allow DNS resolution
    - ports:
        - port: 53
          protocol: UDP
      to: []
    - ports:
        - port: 53
          protocol: TCP
      to: []
    # Allow HTTPS outbound
    - ports:
        - port: 443
          protocol: TCP
      to: []
    # Allow HTTP outbound
    - ports:
        - port: 80
          protocol: TCP
      to: []

# Default values for Collabora.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

{{- /*
  $serverName is the name of the server in the Collabora ecosystem
  $hostName is the hostname the server is available at
  $clientHostName is the host the client is running on
*/ -}}
# {{- $serverName := .Values.global.hostname.collabora | default (printf "%s.%s" .Values.global.hostname.collabora .Values.global.domain) -}}
{{- $hostName := printf "%s.%s" .Values.global.hostname.collabora .Values.global.domain -}}
{{- $clientHostName := printf "%s.%s" .Values.global.hostname.collabora .Values.global.domain -}}


clusterDomain: {{ .Values.cluster.networking.domain | default "cluster.local" | quote }}

global:
  ## Global Docker image parameters
  ## Please, note that this will override the image parameters, including dependencies, configured to use the global value
  ## @param global.imageRegistry Global Docker Image registry
  ## @param global.imagePullSecrets Global Docker registry secret names as an array
  ##
  imageRegistry: {{ .Values.container.default.registry | quote }}
  imagePullSecrets: []
  ## @param global.defaultStorageClass Global default StorageClass for Persistent Volume(s)
  ##
  defaultStorageClass: {{ .Values.pvc.default.storageClass | quote }}
  ## Security parameters
  ## @param global.security.allowInsecureImages Allows skipping image verification
  ##
  security:
    allowInsecureImages: true
  ## Compatibility adaptations for Kubernetes platforms
  ##
  compatibility:
    ## Compatibility adaptations for Openshift
    ## @param global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: auto (apply if the detected running cluster is Openshift), force (perform the adaptation always), disabled (do not perform adaptation)
    ##

    openshift:
      {{- if .Values.application.collabora.enableInsecureCoolWSD }}
      adaptSecurityContext: disabled
      {{- else }}
      adaptSecurityContext: auto
      {{- end }}
    ## @param global.compatibility.omitEmptySeLinuxOptions If set to true, removes the seLinuxOptions from the securityContexts when it is set to an empty object
    ##
    omitEmptySeLinuxOptions: false


# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  registry: {{ coalesce .Values.container.collabora.registry .Values.container.default.registry | quote }}
  repository: {{ .Values.container.collabora.repository }}
  # This sets the pull policy for images.
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: {{ .Values.container.collabora.tag }}
  pullSecrets:
    - {{ coalesce .Values.container.collabora.imagePullSecret .Values.container.default.imagePullSecret | toYaml | nindent 8 }}

collabora:
  # Username used for authenticating with the Collabora service (default: "admin" if not provided in secrets)
  username: {{ .Values.secret.collabora.credentials.username | quote }}

  # Password used for authenticating with the Collabora service (default: "admin" if not provided in secrets)
  password: {{ .Values.secret.collabora.credentials.password | quote }}

  # The hostname that Collabora will use to identify itself (usually matches the external DNS name)
  server_name: {{ .Values.global.hostname.collabora | default "collabora" }}.{{ .Values.global.domain | default "example.com"  }}

  # Extra parameters passed to the Collabora start command; in this case, disables SSL inside the container
  extra_params: --o:ssl.enable=false --o:ssl.termination=true

  # When true, enables OpenShift-specific initContainer workaround.
  enableInsecureCoolWSD : {{ .Values.application.collabora.enableInsecureCoolWSD  | quote }}

  aliasgroups:
    - host: "{{ .Values.global.hostname.nextcloud | default "nextcloud" }}.{{ .Values.global.domain | default "example.com"  }}"

containerPorts:
  # The internal port exposed by the Collabora container (used in deployment)
  http: 9980

service:
  # The Kubernetes service type for Collabora. ClusterIP exposes it internally within the cluster.
  type: ClusterIP

  # The internal service port that Collabora listens on
  port:
    http: 9980

{{- if .Values.cluster.runtimeClassName }}
runtimeClassName: {{ .Values.cluster.runtimeClassName | quote }}
{{- end }}

ingress:
  hostname: {{ .Values.global.hostname.collabora | default "collabora" }}.{{ .Values.global.domain | default "example.com"  }}
  # Enables ingress configuration for external access to Collabora
  enabled: true

  # Specifies the name of the ingress class/controller to use (e.g., "nginx", "traefik", etc.)
  ingressClassName: {{ .Values.cluster.ingress.className | quote }}

  # Enable TLS encryption. Required for HTTPs traffic.
  tls: {{ .Values.global.tls.enabled | default true }}

  # Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  selfSigned: {{ and .Values.global.tls.enabled .Values.global.tls.selfSigned | default false }}

  # Optional TLS configuration injected from Helm values (for enabling HTTPS on the ingress)
  extraTls: {{ .Values.tls.collabora | toYaml | nindent 4 }}
  annotations:
    {{- if .Values.cluster.ingress.annotations }}
    {{ .Values.cluster.ingress.annotations | toYaml | nindent 4 }}
    {{- end }}
    {{- if eq .Values.cluster.ingress.type "nginx" }}
    nginx.ingress.kubernetes.io/upstream-hash-by: "$arg_WOPISrc"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    {{- end }}
    {{- if eq .Values.cluster.ingress.type "haproxy-openshift" }}
    haproxy.org/timeout-tunnel: "3600s"
    haproxy.org/backend-config-snippet: |
      balance url_param WOPISrc check_post
      hash-type consistent
    {{- end }}


  # Host definitions for the ingress resource
  hosts:
  - host: {{ .Values.global.hostname.collabora | default "collabora" }}.{{ .Values.global.domain | default "example.com" | quote }}
    # Path routing rules â€” all requests to "/" will be forwarded to Collabora
    paths:
        - path: /
          pathType: ImplementationSpecific

# Predefined resource configuration level like 'micro', 'small', etc.
resourcesPreset: {{ .Values.global.resourcesPreset | quote }}

# CPU and memory requests and limits for the container
resources: {{ .Values.resource.collabora | toYaml | nindent 2 }}


# Security context settings applied at the pod level
podSecurityContext: {{ coalesce .Values.security.collabora.podSecurityContext .Values.security.default.podSecurityContext | toYaml | nindent 2 }}

# Security context settings specific to the container
containerSecurityContext: {{ coalesce .Values.security.collabora.containerSecurityContext .Values.security.default.containerSecurityContext | toYaml | nindent 2 }}

# Number of desired pod replicas if HPA (autoscaling) is not enabled
replicaCount: 1

# Horizontal Pod Autoscaler configuration, such as min/max replicas and target CPU/memory
# Horizontal Pod Autoscaling (HPA) is disabled for now. Because after scaling it breaks the collaborative editing and copy/paste.
autoscaling:
  hpa: {{ .Values.autoscaling.horizontal.collabora | toYaml | nindent 4 }}

networkPolicy:
  enabled: true
  # Restrict external access - only allow specific ingress sources
  allowExternal: true
  # Restrict external egress - only allow specific destinations
  allowExternalEgress: false

  extraEgress:
    - ports:
       - port: 443
         protocol: TCP

# extraVolumes Additional volumes to be mounted into the pod
extraVolumes:
  - name: nginx-conf
    emptyDir: {}

# extraVolumeMounts Mount paths for the extra volumes defined above
extraVolumeMounts:
  - name: nginx-conf
    mountPath: /etc/nginx/conf.d

# livenessProbe.enabled Enable Kubernetes liveness probe
livenessProbe:
  enabled: true

# readinessProbe.enabled Enable Kubernetes readiness probe
readinessProbe:
  enabled: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # Name of the existing ServiceAccount to use (if any)
  name: ""

# labels for pod assignment
nodeSelector: {}

# Tolerations for pod assignment
tolerations: []

# Affinity rules for pod assignment
affinity: {}

diagnosticMode:
  enabled: false
